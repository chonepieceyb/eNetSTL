# eNetSTL

**Read this in other languages: [English](README.md), [中文](README_zh.md).**

## 1. Directory Structure

```
├── src                     # Network Functions
│   ├── bpf_kern            # eBPF Programs
│   ├── c                   # User-space C Programs
│   ├── python              # Python Experiment Scripts
│   └── LKM                 # Kernel Modules
│        ├── bpf_ptr_structure_lib    # Pointer Class Basic Library
│        ├── eNetSTL                  # SIMD Parallel Hash Basic Library
│        └── expN           # Kernel Modules used for each experiment
├── build                   # eBPF Network Function Build Directory
└── log                     # Experiment Data Directory
```

## 2. Build and Usage

### Download Resources
**Only required for building Docker images or compiling the kernel**
1. Download `resources.tar.gz` from the GITHUB release.
2. Extract it to `Docker/`, resulting in a directory named `Docker/resources`.

### Kernel Installation
Since the baseline for the experiment modifies kernel code and requires Rust support, a new kernel needs to be installed. The kernel image can be found in `resources.tar.gz` from the GITHUB release.

Alternatively, compile the kernel yourself. Patch files are located in `patches`, download [Linux 6.6](https://github.com/torvalds/linux/releases/tag/v6.6), apply the patch, and enable Rust support in the compilation options as described [here](https://docs.kernel.org/rust/index.html).

After compiling, copy the compiled kernel artifact `vmlinux` to `Docker/resources/`.

### Build Docker Image
You can use a pre-built image (using the provided kernel image) with `docker pull chonepieceyb/enetstl:v0.1`, or build the image yourself using the Dockerfile:

1. Switch to the compiled kernel.
2. Build the Docker image:
   ```shell
   cd Docker
   ./build.sh
   ```

### Run Docker
After pulling or building the Docker image, run Docker:
   ```shell
   cd Docker
   ./run.sh
   ```

### Build and Load Kernel Modules

**Subsequent operations are performed in the Docker container directory `/root/eNetSTL`**

Taking the `eNetSTL` module as an example:

1. Navigate to the respective module directory and build the kernel module:
   ```bash
   cd src/LKM/eNetSTL
   make LLVM=1
   ```

2. Load the kernel module:
   ```bash
   sudo insmod eNetSTL.ko
   ```

### Build and Load eBPF Network Functions

1. Modify the network interface bound during network function loading in the `src/c/config.h` file (the receiving network interface for subsequent experiments):
   ```c
   #define XDP_IF "<Interface Name>"
   ```

2. Build the eBPF network function and user-space program:
   ```bash
   mkdir -p build
   cd build
   # If conducting latency testing experiments, set the DUSE_LATENCY_EXP parameter to on
   cmake -DLOG_LEVEL=0 -DUSE_LATENCY_EXP=off ..
   make clean && make -j$(nproc)
   ```

3. After building, the user-space control program (including the BPF program through the BPF skeleton) is in the `bin/` directory and can be executed directly:
   ```bash
   sudo ./bin/empty_base_user
   ```

## 3. Experimental Environment Setup

The experiment requires two physical machines, one for packet sending and the other as the Device Under Test (DUT). The packet sending device needs to have a NIC that supports DPDK.

### Packet Sending Device

Pre-install [DPDK 22.11.6](https://core.dpdk.org/download/) and [Trex v3.03](https://trex-tgn.cisco.com/trex/release/) on the packet sending device.

Configuration of DPDK and installation of Trex can be done following the guidelines provided by Trex [here](https://trex-tgn.cisco.com/trex/doc/trex_manual.html#_download_and_installation).

The default location for Trex's configuration file is `/etc/trex_cfg.yaml`, with the following example configuration.
```yaml
### Config file generated by dpdk_setup_ports.py ###

- version: 2
  interfaces: ['0000:08:00.0', '0000:08:00.1'] # send 
  port_info:
    - src_mac:  6c:b3:11:21:b6:60 # Packet Sending NIC port0 MAC Address
      dest_mac: 6c:b3:11:21:b6:58 # DUT's Packet Receiving NIC MAC 
    - src_mac:  6c:b3:11:21:b6:62 
      dest_mac: 6c:b3:11:21:b6:5a

  platform:
      master_thread_id: 0
      latency_thread_id: 6 # CPU Core for the Latency Measurement Thread
      dual_if:
        - socket: 0
          threads: [1,2,3,4,5] # CPU Core used by the Packet Sending Thread
```

After configuring DPDK huge page memory allocation, binding PMD drivers, and completing Trex's network card configuration, start the Trex server in the Trex installation directory with the following command:
```shell
sudo ./t-rex-64 -i -c 5
```

Ensure the Trex server runs continuously during the experiment.

### Device Under Test (DUT)

#### Preparatory Work

1. Compile all `Kernel Modules` and `eBPF Network Functions` on this device.
2. Modify the `interface_name` variable in the `src/python/exp_config.py` file to the packet receiving NIC name on this device.
3. Modify the `TREX_SERVER` variable in the `src/python/exp_config.py` file to the IP address of the packet sending device.
4. Modify the `LAT_TEST_PORT` variable in the `src/python/exp_config.py` file to the port number of the packet sending NIC configed in Trex.
5. Configure RSS to change the number of queues on the receiving network card to 1.

#### Running the Experiment Script

Execute the following command in the `src/python` directory to perform a throughput experiment:
```shell
sudo python exp.py -c 5 pps
```

After recompiling with the cmake flag `-DUSE_LATENCY_EXP=on`, execute the following command to perform a latency experiment:
```shell
sudo python exp.py -c 5 lat_no
```

This script automates packet sending from the sending device, loading of network functions and kernel modules, data recording, and running of experiments. Once started, wait for it to complete. 

After all experiments are finished, the final experiment data will be recorded in the `log` directory.